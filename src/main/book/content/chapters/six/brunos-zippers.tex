\section{Zippers are not just for Bruno anymore}

\subsection{The history of the zipper}

The origin of the zipper rests in the desire to provide an efficient
functional representation of a ``structure'' editor. For example, we
might consider navigation and destructive modification of a tree. In a
functional representation destructive operations need to be replaced
by copying. Done naively, this can be very expensive.

\subsubsection{Huet's zipper}

In his functional pearl Huet describes a generic approach to the
problem of an applicative structure editor. He dubbed it the
zipper. The key idea is to denote the location of a position in a tree
by splitting it into two pieces: the subtree of focus and the context
in which it appears.

To render this idea in \texttt{Scala} suppose that we have modeled the
type of a tree as

\begin{lstlisting}[language=Scala,mathescape=true]
  trait Tree[A]
  // Leaf
  class TreeItem[A]( val item : A ) extends Tree[A]
  // Branches
  class TreeSection[A](
    val section: List[Tree[A]]
  ) extends Tree[A]  
\end{lstlisting}

with corresponding companion objects for easy construction and
deconstruction. (We'd make these
\lstinline[language=Scala,mathescape=true]!case class!es, but then we
couldn't use inheritance.)

\begin{lstlisting}[language=Scala,mathescape=true]
  object TreeItem {
    def apply[A]( item : A ) = { new TreeItem( item ) }
    def unapply[A]( tree : TreeItem[A] )
    : Option[( A )] = {
      Some( ( tree.item ) )
    }
  }
  object TreeSection {
    def apply[A]( section : List[Tree[A]] ) = {
      new TreeSection( section )
    }
    def unapply[A]( tree : TreeSection[A] )
    : Option[( List[Tree[A]] )] = {
      Some( ( tree.section ) )
    }
  }
\end{lstlisting}

then we would model a context in the tree as

\begin{lstlisting}[language=Scala,mathescape=true]
  trait Context[A]
  case class Top[A]( ) extends Context[A]
  class TreeContext[A](
    val left : List[Tree[A]],
    val ctxt : Context[A],
    val right : List[Tree[A]]
  ) extends Context[A]
\end{lstlisting}

Essentially, a \lstinline[language=Scala,mathescape=true]!Context!
denotes a place where we might ``plugin'' a subtree. Thus, it
identifies the branches to the left, the branches to the right and a
``path'' to a ``hole''.

Of course, we have the obligatory companion object.

\begin{lstlisting}[language=Scala,mathescape=true]
  object TreeContext {
    def apply[A](
      left : List[Tree[A]],
      ctxt : Context[A],
      right : List[Tree[A]] ) = {
        new TreeContext( left, ctxt, right )
      }
      def unapply[A]( ctxt : TreeContext[A] )
      : Option[( List[Tree[A]], Context[A], List[Tree[A]] )] = {
        Some( ( ctxt.left, ctxt.ctxt, ctxt.right ) )
      }
  }
\end{lstlisting}

Since it is clear how this boilerplate is made, we will dispense with
it in subsequent discussion; but note that the cost in boilerplate may
not have been worth deprecating inheritance in
\lstinline[language=Scala,mathescape=true]!case class!es.

Now, we have the types necessary to model our intuitions as to what a
location is. It's a pair of a context and a tree that plugs into the
context. Note that neither of these datum are suffient in an of
themselves to identify a location in a tree. The subtree could occur
in any number of trees. Likewise, the context could be filled with any
number of subtrees. It takes the pair to identify a location in a
tree. For those with some experience in mathematics, this idea is
strongly reminiscent of both Dedekind cuts and Conway's models of
games as numbers.

\begin{lstlisting}[language=Scala,mathescape=true]
  class Location[A](
    val tree : Tree[A],
    val ctxt : Context[A]
  )  
\end{lstlisting}

As a paradigmatic example consider (a crude model of) the syntax tree
of an arithmetic expression. (Now, the decision to model a tree as a
\lstinline[language=Scala,mathescape=true]!class! becomes clear.)

\begin{lstlisting}[language=Scala,mathescape=true]
  case class Token[A](
   override item : A
  ) extends TreeItem[A]( item )
  case class AST[A](
    override section : List[Tree[A]]
  ) extends TreeSection[A]( section )
\end{lstlisting}

Then an instance might look like

\begin{lstlisting}[language=Scala,mathescape=true]
  AST[String](
    List(
      AST[String](
        List(
          Token[String]( "a" ),
          Token[String]( "*" ),
          Token[String]( "b" )
        )
      ),
      Token[String]( "+" ),
      AST[String](
        List(
          Token[String]( "c" ),
          Token[String]( "*" ),
          Token[String]( "d" )
        )
      )
    )
  )
\end{lstlisting}

Then the location of the second multiplication sign is:

\begin{lstlisting}[language=Scala,mathescape=true]
  Location[String](
    Token[String]( "*" ),
    TreeContext[String](
      List( Token[String]( "c" ) ),
      TreeContext[String](
        List(
          Token[String]( "+" ),
          AST[String](
            List(
              Token[String]( "a" ),
              Token[String]( "*" ),
              Token[String]( "b" )
              )
            )
          ),
          Top( ),
          List( )
          ),
      List( Token[String]( "d" ) )
    )
  )
\end{lstlisting}

\paragraph{The navigation functions} With this structure we can define
generic navigation functions.

\begin{lstlisting}[language=Scala,mathescape=true]
trait ZipperNavigation[A] {
  def left( location : Location[A] ) : Location[A] = {
    location match {
      case Location( _, Top ) => {
        throw new Exception( "left of top" )
      }
      case Location( t, TreeContext( l :: left, up, right ) ) => {
        Location( l, TreeContext( left, up, t :: right ) )
      }
      case Location( t, TreeContext( Nil, up, right ) ) => {
        throw new Exception( "left of first" )
      }
    }
  }
  def right( location : Location[A] ) : Location[A] = {
    location match {
      case Location( _, Top ) => {
        throw new Exception( "right of top" )
      }
      case Location( t, TreeContext( left, up, r :: right ) ) => {
        Location( r, TreeContext( t :: left, up, right ) )
      }
      case Location( t, _ ) => {
        throw new Exception( "right of last" )
      }
    }
  }
  def up( location : Location[A] ) : Location[A] = {
    location match {
      case Location( _, Top ) => {
        throw new Exception( "up of top" )
      }   
      case Location( t, TreeContext( left, up, right ) ) => {
        Location( TreeSection[A]( left.reverse ::: ( t :: right ) ),
                  up )
      }
    }
  }
  def down( location : Location[A] ) : Location[A] = {
    location match {
      case Location( TreeItem( _ ), _ ) => {
        throw new Exception( "down of item" )
      }
      case Location( TreeSection( u :: trees ), ctxt ) => {
        Location( u, Context( Nil, ctxt, trees ) )
      }
    }
  }
}
\end{lstlisting}

\paragraph{Exercising the zipper} We can exercise the zipper
navigation functions using the two examples from above.

\begin{lstlisting}[language=Scala,mathescape=true]
  object Exercise extends ZipperNavigation[String] {
    val arithmeticExpr1 = ...

    val locationOf2ndMult = ...

     def show( depth : Int )( tree : Tree[String] ) : Unit = {
       tree match {
         case TreeItem( item : String ) => {
           val indent =
           ( "" /: (1 to depth) )( { ( acc, d ) => acc + " " } )
           println( indent + "Leaf : " + item )
         }
         case TreeSection( section : List[Tree[String]] ) => {
           for( t <- section ){ show( depth + 2 )( t ) }
         }
       }
     }     
   }
\end{lstlisting}

\begin{lstlisting}[language=Scala,mathescape=true]
  scala> import Exercise._
  import Exercise._
  import Exercise._

  scala> show( 0 )( arithmeticExpr1 )
  show( 0 )( arithmeticExpr1 )
    Leaf : a
    Leaf : *
    Leaf : b
  Leaf : +
    Leaf : c
    Leaf : *
    Leaf : d

  scala> show( 0 )( locationOf2ndMult.tree )
  show( 0 )( locationOf2ndMult.tree )
  Leaf : *

  scala> show( 0 )( up( locationOf2ndMult ).tree )
  show( 0 )( up( locationOf2ndMult ).tree )
  Leaf : c
  Leaf : *
  Leaf : d

  scala> show( 0 )( up( up( locationOf2ndMult ) ).tree )
  show( 0 )( up( up( locationOf2ndMult ) ).tree )
    Leaf : a
    Leaf : *
    Leaf : b
  Leaf : +
    Leaf : c
    Leaf : *
    Leaf : d

  scala> show( 0 )( up( up( up( locationOf2ndMult ) ) ).tree )
  show( 0 )( up( up( up( locationOf2ndMult ) ) ).tree )
  java.lang.Exception: up of top
        ...
  scala> 
\end{lstlisting}

Of course, the real desiderata are the mutation functions.

\begin{lstlisting}
  trait ZipperMutation[A] {
    def update(
    location : Location[A], tree : Tree[A]
    ) : Location[A] = {
      location match {
        case Location( _, ctxt ) =>
	  Location( tree, ctxt )
        }
      }
    def insertRight(
      location : Location[A], tree : Tree[A]
    ) : Location[A] = {
      location match {
        case Location( _, Top( ) ) => {
          throw new Exception( "insert of top" )
        }
        case Location(
	  curr, TreeContext( left, up, right )
        ) => {
          Location(
	    curr, TreeContext( left, up, tree :: right )
          )	
        }
      }    
    }
    def insertLeft(
      location : Location[A], tree : Tree[A]
    ) : Location[A] = {
      location match {
        case Location( _, Top( ) ) => {
          throw new Exception( "insert of top" )
        }
        case Location(
	  curr, TreeContext( left, up, right )
        ) => {
          Location(
	    curr, TreeContext( tree :: left, up, right )
          )	
        }
      }    
    }
    def insertDown(
      location : Location[A], tree : Tree[A]
    ) : Location[A] = {
      location match {
        case Location( TreeItem( _ ), _ ) => {
          throw new Exception( "down of item" )
        }
        case Location(
	  TreeSection( progeny ), ctxt
        ) => {
          Location(
	    tree, TreeContext( Nil, ctxt, progeny )
          )
        }
      }
    }
    def delete(
      location : Location[A], tree : Tree[A]
    ) : Location[A] = {
      location match {
        case Location( _, Top( ) ) => {
          throw new Exception( "delete of top" )
        }
        case Location(
	  _, TreeContext( left, up, r :: right )
        ) => {
          Location(
	    r, TreeContext( left, up, right )
          )
        }
        case Location(
	  _, TreeContext( l :: left, up, Nil )
        ) => {
          Location(
	    l, TreeContext( left, up, Nil )
          )
        }
        case Location(
	  _, TreeContext( Nil, up, Nil )
        ) => {
          Location( TreeSection( Nil ), up )
        }
      }
    }
  }
\end{lstlisting}

\subsubsection{Zippers generically}

\paragraph{Two kinds of genericity} 
It turns out that Huet's discovery can be made to work on a much wider
class of structures than ``just'' trees. Intuitively speaking, if their
type arguments are ``zippable'', then virtually all of the common
functional data type constructors, including sequencing constructors
like product, and branching constructors, like summation or
``casing'', result in ``zippable'' types. That is, there are
procedures for deriving a notion of zipper capable of traversing and
mutating the structure. Essentially, there are two strategies to
achieve this genericity: one is based on structural genericity and the
other on procedural genericity.

\paragraph{Genericity of structure}

The former approach relies on being able to define a notion of context
for any ``reasonable'' data structure. Not surprisingly, it turns out
that we can give a good definition of ``reasonable''. What is
surprising is that the resulting definition is amenable to an
operation that perfectly mimics the notion of derivative from Newton's
calculus. The operation is an operation on \emph{types}. This allows
us to give a type-level definition of the notion of location -- just
as we did with trees, but now for any type.

We can use \texttt{Scala}'s type notation to see where the new
genericity has been added. The type of trees in the example is already
polymorphic:
\lstinline[language=Scala,mathescape=true]!Tree[A]!. That's what
having that type parameter
\lstinline[language=Scala,mathescape=true]!A! means. The navigation
trait is therefore also parametric in
\lstinline[language=Scala,mathescape=true]!A!. The navigation trait,
however, is hardcoded in the container type,
\lstinline[language=Scala,mathescape=true]!Tree[A]!. When we add this
second level of genericity, the navigation trait will have to take a
second, \emph{higher-kinded} type parameter for the container because
it will work on any container within a range of reasonably defined
containers.

The use case we have been considering -- navigating and mutating an
in-memory representation of a tree -- is then extended to navigating
and mutating an in-memory representation of an arbitrary data
structure. Moreover, the code is purely functional -- with all of the
attendant advantages of purely functional code we have been observing
since Chapter 1. Obviously, in the context of the web, this particular
use case is of considerable interest. Nearly, every web application is
of this form: navigating a tree or graph of pages. Usually, that graph
of pages is somehow homomorphic, i.e. an image of, the graph of some
underlying domain data structure, like the data structures of employee
records in a payroll system, or the social graph of a social media
application like Twitter. Many web applications, such as so-called
content management systems, also support the mutation of the graph of
pages. So, having a method of generating this functionality from the
types of the underlying data domain, be they web pages, or some other
domain data type, is clearly pertinent to the most focused of
application developers.

And yet, the notion of a \emph{derivative of data types} is
irresistably intriguing. It's not simply that it has many other
applications besides web navigation and update. That a calculational
device that an Englishman discovered some 400+ years ago in his
investigations for providing a mathematical framework for gravitation
and other physical phenomena should be applicable to structuring
computer programs is as surprising as it is elegant and that makes it
\emph{cool}.

\paragraph{Genericity of control}

The latter approach to generically constructing zippers is just as
rich in terms of the world of ideas it opens up as it is in the
imminent practicality of its immediate applications. The key insight
is to abstract on control, rather than on form. Not surprisingly, then
the central tool is the (delimited) continuation. To be clear, in
this approach, originally developed by Oleg Kiselyov, navigation is
reifed as a function and supplied as a parameter. In this sense, it is
not automagically deriving mechanism for navigation, as does the
structural approach. The semantics of mutation, on the other hand, is
provided with a powerful generative mechanism. More specifically, a
dial is provided for the visibility of mutation with respect to
different threads of control. In other words, fine-grained constrol on
the \emph{transactional semantics} of mutating the data structure is
provided. This is exceptionally powerful because, as we have mentioned
since Chapter 1, the transactional semantics is one of the principal
places on which performance of a system -- especially a high-volume
system -- hinges; but, by being based on a form of monad, namely
delimited continuations, the abstraction gets the compiler
involved. This has the effect of enlisting the compiler in maintaining
discipline and sanity on transaction semantics -- which is vitally
important when supplying a fine-grained control on something as
performance-critical as the semantics and visibility of update.
