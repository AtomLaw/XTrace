\section{Zippers are not just for Bruno anymore}

\subsection{The history of the zipper}

The origin of the zipper rests in the desire to provide an efficient
functional representation of a ``structure'' editor. For example, we
might consider navigation and destructive modification of a tree. In a
functional representation destructive operations need to be replaced
by copying. Done naively, this can be very expensive.

\subsubsection{Huet's zipper}

In his functional pearl Huet describes a generic approach to the
problem of an applicative structure editor. He dubbed it the
zipper. The key idea is to denote the location of a position in a tree
by splitting it into two pieces: the subtree of focus and the context
in which it appears.

To render this idea in \texttt{Scala} suppose that we have modeled the
type of a tree as

\begin{lstlisting}[language=Scala,mathescape=true]
  trait Tree[A]
  class TreeItem[A]( val item : A ) extends Tree[A]
  object TreeItem {
    def apply[A]( item : A ) = { new TreeItem( item ) }
    def unapply[A]( tree : TreeItem[A] )
    : Option[( A )] = {
      Some( ( tree.item ) )
    }
  }
  class TreeSection[A]( val section: List[Tree[A]] )
  extends Tree[A]
  object TreeSection {
    def apply[A]( section : List[Tree[A]] ) = {
      new TreeSection( section )
    }
    def unapply[A]( tree : TreeSection[A] )
    : Option[( List[Tree[A]] )] = {
      Some( ( tree.section ) )
    }
  }
\end{lstlisting}

then we would model a context in the tree as

\begin{lstlisting}[language=Scala,mathescape=true]
  trait Context[A]
  case class Top[A]( ) extends Context[A]
  class TreeContext[A](
    val left : List[Tree[A]],
    val ctxt : Context[A],
    val right : List[Tree[A]]
  ) extends Context[A]
  object TreeContext {
    def apply[A](
      left : List[Tree[A]],
      ctxt : Context[A],
      right : List[Tree[A]] ) = {
        new TreeContext( left, ctxt, right )
      }
      def unapply[A]( ctxt : TreeContext[A] )
      : Option[( List[Tree[A]], Context[A], List[Tree[A]] )] = {
        Some( ( ctxt.left, ctxt.ctxt, ctxt.right ) )
      }
  }
\end{lstlisting}

then a location is

\begin{lstlisting}[language=Scala,mathescape=true]
  class Location[A](
    val tree : Tree[A],
    val ctxt : Context[A]
  )
  object Location {
    def apply[A]( tree : Tree[A], ctxt : Context[A] ) = {
      new Location( tree, ctxt )
    }
    def unapply[A]( loc : Location[A] )
    : Option[( Tree[A], Context[A] )] = {
      Some( ( loc.tree, loc.ctxt ) )
    }
  }  
\end{lstlisting}

As a paradigmatic example consider (a crude model of) the syntax tree
of an arithmetic expression.

\begin{lstlisting}[language=Scala,mathescape=true]
  case class Token[A](
   override item : A
  ) extends TreeItem[A]( item )
  case class AST[A](
    override section : List[Tree[A]]
  ) extends TreeSection[A]( section )
\end{lstlisting}

Then an instance might look like

\break

\begin{lstlisting}[language=Scala,mathescape=true]
  AST[String](
    List(
      AST[String](
        List(
          Token[String]( "a" ),
          Token[String]( "*" ),
          Token[String]( "b" )
        )
      ),
      Token[String]( "+" ),
      AST[String](
        List(
          Token[String]( "c" ),
          Token[String]( "*" ),
          Token[String]( "d" )
        )
      )
    )
  )
\end{lstlisting}

Then the location of the second multiplication sign is:

\begin{lstlisting}[language=Scala,mathescape=true]
  Location[String](
    Token[String]( "*" ),
    TreeContext[String](
      List( Token[String]( "c" ) ),
      TreeContext[String](
        List(
          Token[String]( "+" ),
          AST[String](
            List(
              Token[String]( "a" ),
              Token[String]( "*" ),
              Token[String]( "b" )
              )
            )
          ),
          Top( ),
          List( )
          ),
      List( Token[String]( "d" ) )
    )
  )
\end{lstlisting}

\paragraph{The navigation functions} With this structure we can define
generic navigation functions.

\begin{lstlisting}[language=Scala,mathescape=true]
trait ZipperNavigation[A] {
  def left( location : Location[A] ) : Location[A] = {
    location match {
      case Location( _, Top ) => {
        throw new Exception( "left of top" )
      }
      case Location( t, TreeContext( l :: left, up, right ) ) => {
        Location( l, TreeContext( left, up, t :: right ) )
      }
      case Location( t, TreeContext( Nil, up, right ) ) => {
        throw new Exception( "left of first" )
      }
    }
  }
  def right( location : Location[A] ) : Location[A] = {
    location match {
      case Location( _, Top ) => {
        throw new Exception( "right of top" )
      }
      case Location( t, TreeContext( left, up, r :: right ) ) => {
        Location( r, TreeContext( t :: left, up, right ) )
      }
      case Location( t, _ ) => {
        throw new Exception( "right of last" )
      }
    }
  }
  def up( location : Location[A] ) : Location[A] = {
    location match {
      case Location( _, Top ) => {
        throw new Exception( "up of top" )
      }   
      case Location( t, TreeContext( left, up, right ) ) => {
        Location( TreeSection[A]( left.reverse ::: ( t :: right ) ),
                  up )
      }
    }
  }
  def down( location : Location[A] ) : Location[A] = {
    location match {
      case Location( TreeItem( _ ), _ ) => {
        throw new Exception( "down of item" )
      }
      case Location( TreeSection( u :: trees ), ctxt ) => {
        Location( u, Context( Nil, ctxt, trees ) )
      }
    }
  }
}
\end{lstlisting}

\paragraph{Exercising the zipper} We can exercise the zipper
navigation functions using the two examples from above.

\begin{lstlisting}[language=Scala,mathescape=true]
  object Exercise extends ZipperNavigation[String] {
    val arithmeticExpr1 =
      AST[String](
        List(
	  AST[String](
            List(
              Token[String]( "a" ),
              Token[String]( "*" ),
              Token[String]( "b" )
           )
         ),
         Token[String]( "+" ),
         AST[String](
           List(
             Token[String]( "c" ),
             Token[String]( "*" ),
             Token[String]( "d" )
           )
	)
      )
    )

    val locationOf2ndMult =
      Location[String](
        Token[String]( "*" ),
        TreeContext[String](
	  List( Token[String]( "c" ) ),
          TreeContext[String](
            List(
              Token[String]( "+" ),
              AST[String](
                List(
		  Token[String]( "a" ),
                  Token[String]( "*" ),
                  Token[String]( "b" )
                )
              )
            ),
            Top( ),
            List( )
          ),
          List( Token[String]( "d" ) )
       )
     )

     def show( depth : Int )( tree : Tree[String] ) : Unit = {
       tree match {
         case TreeItem( item : String ) => {
           val indent =
           ( "" /: (1 to depth) )( { ( acc, d ) => acc + " " } )
           println( indent + "Leaf : " + item )
         }
         case TreeSection( section : List[Tree[String]] ) => {
           for( t <- section ){ show( depth + 2 )( t ) }
         }
       }
     }     
   }
\end{lstlisting}

\break

\begin{lstlisting}[language=Scala,mathescape=true]
  scala> import Exercise._
  import Exercise._
  import Exercise._

  scala> show( 0 )( arithmeticExpr1 )
  show( 0 )( arithmeticExpr1 )
    Leaf : a
    Leaf : *
    Leaf : b
  Leaf : +
    Leaf : c
    Leaf : *
    Leaf : d

  scala> show( 0 )( locationOf2ndMult.tree )
  show( 0 )( locationOf2ndMult.tree )
  Leaf : *

  scala> show( 0 )( up( locationOf2ndMult ).tree )
  show( 0 )( up( locationOf2ndMult ).tree )
  Leaf : c
  Leaf : *
  Leaf : d

  scala> show( 0 )( up( up( locationOf2ndMult ) ).tree )
  show( 0 )( up( up( locationOf2ndMult ) ).tree )
    Leaf : a
    Leaf : *
    Leaf : b
  Leaf : +
    Leaf : c
    Leaf : *
    Leaf : d

  scala> show( 0 )( up( up( up( locationOf2ndMult ) ) ).tree )
  show( 0 )( up( up( up( locationOf2ndMult ) ) ).tree )
  java.lang.Exception: up of top
        ...
  scala> 
\end{lstlisting}

Of course, the real desiderata are the mutation functions.

\begin{lstlisting}
  trait ZipperMutation[A] {
    def update(
      location : Location[A],
      tree : Tree[A]
    ) : Location[A] = {
      location match {
        case Location( _, ctxt ) =>
	  Location( tree, ctxt )
        }
      }
    def insertRight(
      location : Location[A],
      tree : Tree[A]
    ) : Location[A] = {
      location match {
        case Location( _, Top( ) ) => {
          throw new Exception( "insert of top" )
        }
        case Location(
	  curr,
          TreeContext( left, up, right )
        ) => {
          Location(
	    curr,
            TreeContext( left, up, tree :: right )
          )	
        }
      }    
    }
    def insertLeft(
      location : Location[A], tree : Tree[A]
    ) : Location[A] = {
      location match {
        case Location( _, Top( ) ) => {
          throw new Exception( "insert of top" )
        }
        case Location(
	  curr,
          TreeContext( left, up, right )
        ) => {
          Location(
	    curr,
            TreeContext( tree :: left, up, right )
          )	
        }
      }    
    }
    def insertDown(
      location : Location[A],
      tree : Tree[A]
    ) : Location[A] = {
      location match {
        case Location( TreeItem( _ ), _ ) => {
          throw new Exception( "down of item" )
        }
        case Location(
	  TreeSection( progeny ),
          ctxt
        ) => {
          Location(
	    tree,
            TreeContext( Nil, ctxt, progeny )
          )
        }
      }
    }
    def delete(
      location : Location[A],
      tree : Tree[A]
    ) : Location[A] = {
      location match {
        case Location( _, Top( ) ) => {
          throw new Exception( "delete of top" )
        }
        case Location(
	  _,
          TreeContext( left, up, r :: right )
        ) => {
          Location(
	    r,
            TreeContext( left, up, right )
          )
        }
        case Location(
	  _,
          TreeContext( l :: left, up, Nil )
        ) => {
          Location(
	    l,
            TreeContext( left, up, Nil )
          )
        }
        case Location(
	  _,
          TreeContext( Nil, up, Nil )
        ) => {
          Location( TreeSection( Nil ), up )
        }
      }
    }
  }
\end{lstlisting}

\subsubsection{Zippers generically}

