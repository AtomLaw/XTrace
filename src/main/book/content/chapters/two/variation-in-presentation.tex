\section{Variations in presentation}

Given that we have a type constructor, $T$

In Haskell a monad is presented in terms of the following data

% \begin{list}
%   \item a ``return'' map enjoying the signature $return : a \to T a$
%   \item a ``bind'' map enjoying the signature $>>= : T a \to a \to T
%     b \to T b$
% \end{list}

subject to the following laws:

% \begin{list}
%   \item[Left identity] $return a >>= f  ≡  f a$
%   \item[Right identity] $m >>= return  ≡  m$
%   \item[Associativity] $(m >>= f) >>= g  ≡  m >>= (\x -> f x >>= g)$
% \end{list}

while in category theory the monad is presented in terms of the
following data

% \begin{list}
%   \item a ``unit'' map enjoying the signature $unit : A \to T[A]$
%   \item a ``mult'' map enjoying the signature $mult : T[T[A]] \to T[A]$
% \end{list}

subject to the following laws:

% \begin{list}
%   \item[Functoriality] $T( id_A ) = id_{T[A]}$
%   \item[Naturality]
%     \begin{list}
%     \item[unit] $unit(f) \circ unit_{A} = unit_{B} \circ unit(B)$
%     \item[mult] $mult(f) \circ mult_{T[A]} = mult_{T[B]} \circ mult(B)$
%     \end{list}
%   \item[Coherence]
%     \begin{list}
%     \item[mult-mult] $mult \circ T mult = mult \circ mult T$
%     \item[mult-unit] $mult \circ T unit = mult unit T$
%     \end{list}
% \end{list}

These two definitions are interchangeable. That's what makes them
``presentations'' of the same underlying idea.

One of the reasons for the difference in presentation is that Haskell
doesn't treat the Monad type class as a Functor. The refactoring of
the $mult$ map into the $bind$ map is that it builds functoriality
into definition. The other reason is the do notation.

% TODO: wrap this in listing tags

% do { x } = x
 
% do { x ; <stmts> }
%   = x >> do { <stmts> }
 
% do { v <- x ; <stmts> }
%   = x >>= \v -> do { <stmts> }
 
% do { let <decls> ; <stmts> }
%   = let <decls> in do { <stmts> }

Scala follows Haskell, though the same notation is called
for-notation. The basic construct looks like

%for( p <- e [; p <- e] [p = e] [if t] ) yield { e }

and the de-sugaring looks like

% TODO write down Scala for-notation desugaring

This means, therefore, that we have the following correspondence

% TODO write down the Haskell/Scala monad correspondence

Unlike Haskell, Scala did not reify the notion of monad under the
language's equivalent of the Haskell type class. Instead the
systematic means of de-sugaring for-notation and polymorphic
interpretations of flatMap, etc are the effective definitions of
monads in Scala.

If one were to reify the notion in Scala there are several design
choices -- all of which endure some desiderata. Following category
theory, however, has some crucial advantages: namely, the constraints
on any given monad candidate are well factored into functoriality,
naturality and coherence. Often these can be mechanically verified,
and when they can't there are natural ways to generate spot-checks
that fit well with tools such as ScalaCheck.
