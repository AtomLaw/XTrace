\section{Where are we}

\subsection{The concurrency squeeze: from the hardware up, from the web down}

It used to be fashionable in academic papers or think tank reports to
predict or bemoan the imminent demise of Moore's law, to wax on about
the need to ``go sideways'' in hardware design from the number of
cores per die to the number of processors per box. Those days of
polite conversation about the on coming storm are definitely in our
rear view mirror. Today's developer knows that if her program is
commercially interesting at all then it needs to be web-accessible on
a 24x7 basis; and if it's going to be commercially significant it will
need to support at least 100's if not thousands of concurrent accesses
to its features and functions. Her application is most likely hosted
by some commercial outfit, a Joyent or an EngineYard or an Amazon EC3
or $\ldots$ who are deploying her code over multiple servers each of
which is in turn multi-processor with multiple cores. This means that
from the hardware up and from the web down today's intrepid developer
is dealing with parallelism, concurrency and distribution.

Unfortunately, the methods available in in mainstream programming
languages of dealing with these different aspects of simultaneous
execution are not up to the task of supporting development at this
scale. The core issue is complexity. The modern application developer
is faced with a huge range of concurrency and concurrency control
models, from transactions in the database to message-passing between
server components. Whether to partition her data is no longer an
option, she's thinking hard about \emp{how} to partition her data and
whether or not this ``eventual consistency'' thing is going to
liberate her or bring on a new host of programming nightmares. By
comparison threads packages seem like quaint relics from a time when
concurrent programming was a little hobby project she did after
hours. The modern programmer needs to simplify her life in order to
maintain a competitive level of productivity.

\subsection{Ubiquity of robust, high-performance virtual machines}

\subsection{Advances in functional programming, monads and the awkward squad}

