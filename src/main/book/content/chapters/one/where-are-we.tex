\section{Where are we}

\subsection{The concurrency squeeze: from the hardware up, from the web down}

It used to be fashionable in academic papers or think tank reports to
predict or bemoan the imminent demise of Moore's law, to wax on about
the need to ``go sideways'' in hardware design from the number of
cores per die to the number of processors per box. Those days of
polite conversation about the on coming storm are definitely in our
rear view mirror. Today's developer knows that if her program is
commercially interesting at all then it needs to be web-accessible on
a 24x7 basis; and if it's going to be commercially significant it will
need to support at least 100's if not thousands of concurrent accesses
to its features and functions. Her application is most likely hosted
by some commercial outfit, a Joyent or an EngineYard or an Amazon EC3
or $\ldots$ who are deploying her code over multiple servers each of
which is in turn multi-processor with multiple cores. This means that
from the hardware up and from the web down today's intrepid developer
is dealing with parallelism, concurrency and distribution.

Unfortunately, the methods available in in mainstream programming
languages of dealing with these different aspects of simultaneous
execution are not up to the task of supporting development at this
scale. The core issue is complexity. The modern application developer
is faced with a huge range of concurrency and concurrency control
models, from transactions in the database to message-passing between
server components. Whether to partition her data is no longer an
option, she's thinking hard about \emp{how} to partition her data and
whether or not this ``eventual consistency'' thing is going to
liberate her or bring on a new host of programming nightmares. By
comparison threads packages seem like quaint relics from a time when
concurrent programming was a little hobby project she did after
hours. The modern programmer needs to simplify her life in order to
maintain a competitive level of productivity.

Functional programming provides a sort of transition technology. On
the one hand, it's not that much of a radical departure from
mainstream programming like Java. On the other it offers simple,
uniform model that introduces a number of key features that
considerably improve productivity and maintainability. Java brought
the C/C++ programmer several steps closer to a functional paradigm,
introducing garbage collection, type abstractions such as generics and
other niceties. Languages like OCaml, F# and Scala go a step further,
bringing the modern developer into contact with higher order
functions, the relationship between types and pattern matching and
powerful abstractions like monads. Yet, functional programming does
not embrace concurrency and distribution in its foundations. It is not
based a model of computation, like the actor model or the process
calculi that are based on a notion of execution that is fundamentally
concurrent. That said, it meshes nicely with a variety of concurrency
programming models. In particular, the combination of higher order
functions (with the ability to pass functions as arguments and return
functions as values) together with the structuring techniques of
monads make models such as software transactional memory or data flow
parallelism quite easy to integrate, while pattern-matching
additionally makes message-passing style easier to incorporate.

\subsection{Ubiquity of robust, high-performance virtual machines}



\subsection{Advances in functional programming, monads and the awkward squad}

